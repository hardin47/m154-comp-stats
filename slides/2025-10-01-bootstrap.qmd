---
title: "Bootstrapping"
author: "Jo Hardin"
subtitle: "October 1 + 6 + 8 + 15, 2025"
format: 
  revealjs:
    incremental: false
    scrollable: true
    slide-number: true
    show-slide-number: all
    embed-resources: true
    html-math-method: mathjax
execute:
  echo: true
  warning: false
  message: false
bibliography: 
  - ../slides.bib
---


```{r include=FALSE}
library(tidyverse)
library(mosaic)
library(boot)
library(skimr)
options(pillar.width = 70)
```



# Agenda 10/1/25

1. Review: logic of SE
2. Logic of bootstrapping (resample from the sample *with* replacement)
3. BS SE of a statistic



## Why bootstrap?

Motivation:  

> to estimate the variability and distribution of a statistic in repeated samples of size $n$ (*not* dependent on $H_0$ being true).



## Variability

* standard deviation of the **data**: $s = \sqrt{\frac{\sum_{i=1}^n(X_i - \overline{X})^2}{n-1}}$

* standard error of the **statistic**: depends...



## Intuitive understanding

See in the applets for an intuitive understanding of both confidence intervals and bootstrapping:

* <a href = "http://www.lock5stat.com/StatKey/" target = "_blank">StatKey applets</a> which demonstrate bootstrapping.

* <a href = "http://www.rossmanchance.com/applets/ConfSim.html" target = "_blank">Confidence interval logic</a> from the Rossman & Chance applets.




## Basic Notation

(n.b., we don't ever do what is on this slide)

Let $\theta$ be the parameter of interest, and let $\hat{\theta}$ be the estimate of $\theta$.  If we could, we'd take many samples of size $n$ from the population to create a **sampling distribution** for $\hat{\theta}$.  Consider taking $B$ random samples from the population.

\begin{align}
\hat{\theta}(\cdot) = \frac{1}{B} \sum_{i=1}^B \hat{\theta}_i
\end{align}
is the best guess for $\theta$.  If $\hat{\theta}$ is very different from $\theta$, we would call it **biased**.
\begin{align}
SE(\hat{\theta}) &= \bigg[ \frac{1}{B-1} \sum_{i=1}^B(\hat{\theta}_i - \hat{\theta}(\cdot))^2 \bigg]^{1/2}\\
%q_1 &= [0.25 B] \ \ \ \ \hat{\theta}^{(q_1)} = \mbox{25}\% \mbox{ cutoff}\\
%q_3 &= [0.75 B] \ \ \ \ \hat{\theta}^{(q_3)} = \mbox{75}\% \mbox{ cutoff}\\
\end{align}



## Ideally

(we never do part (a))

```{r out.width='60%', fig.align="center",  echo=FALSE, fig.cap = "From Hesterberg et al., Chapter 16 of Introduction to the Practice of Statistics by  Moore, McCabe, and Craig"}
knitr::include_graphics("../images/BSlogic.png")
```



## Bootstrap Procedure

1. Resample data **with replacement** from the original sample.
2. Calculate the statistic of interest for each resample.
3. Repeat 1. and 2. $B$ times.
4. Use the bootstrap distribution for inference.



## Bootstrap Notation

(n.b., bootstrapping is the process on this slide)

Take many ( $B$ ) resamples of size $n$ from the sample to create a bootstrap distribution for $\hat{\theta}^*$ (instead of the sampling distribution for $\hat{\theta}$).

Let $\hat{\theta}^*(b)$ be the calculated statistic of interest for the $b^{th}$ bootstrap sample.  The best guess for $\theta$ is:
\begin{align}
\hat{\theta}^* = \frac{1}{B} \sum_{b=1}^B \hat{\theta}^*(b)
\end{align}
(if $\hat{\theta}^*$ is very different from $\hat{\theta}$, we call it biased.)  And the estimated value for the standard error of the estimate is
\begin{align}
\hat{SE}^* = \bigg[ \frac{1}{B-1} \sum_{b=1}^B ( \hat{\theta}^*(b) - \hat{\theta}^*)^2 \bigg]^{1/2}
\end{align}



## What do we get?


Just like repeatedly taking samples from the population, taking resamples from the sample allows us to characterize the bootstrap distribution which approximates the sampling distribution.  

> The bootstrap distribution approximates the **shape, spread, & bias** of the true sampling distribution.



```{r out.width='30%', fig.align="center",  echo=FALSE, fig.cap = "From Hesterberg et al., Chapter 16 of Introduction to the Practice of Statistics by  Moore, McCabe, and Craig.  The left image represents the mean with n=50.  The center image represents the mean with n=9.  The right image represents the median with n=15.", fig.show='hold'}
knitr::include_graphics(c("../images/BShesterberg1.png",
                          "../images/BShesterberg2.png",
                          "../images/BShesterberg3.png"))
```



## Example
- @everitt2006 report on a study by @caplehorn1991 that investigated the time (days) spent in a clinic for methadone maintenance treatment for people addicted to heroin.  

- The data include the amount of time that the subjects stayed in the facility until treatment was terminated. 

- For about 37% of the subjects, the study ended while they were still the in clinic (status=0).  

- Their survival time has been truncated.  For this reason we might not want to estimate the mean survival time, but rather some other measure of typical survival time.  Below we explore using the median as well as the 25% trimmed mean.   (From @iscam, Investigation 4.5.3)



## The data
```{r echo = FALSE}
heroin <- readr::read_table("http://www.rossmanchance.com/iscam2/data/heroin.txt")
heroin |>
  select(-prison)
```




## Observed Statistic(s)
```{r}
heroin |>
  summarize(obs_med = median(times), 
            obs_tr_mean = mean(times, trim = 0.25))

```




## Bootstrapped data!

```{r}
set.seed(4747)

heroin |> 
  sample_frac(size=1, replace=TRUE) |>
  summarize(boot_med = median(times), 
            boot_tr_mean = mean(times, trim = 0.25))

```




##  Bootstrapping with `map()` 

::: {.panel-tabset}

## set variables
```{r}
n_rep1 <- 100
n_rep2 <- 20
set.seed(4747)
```

## data
```{r}
heroin
```


## boot stat function
```{r}
boot_stat_func <- function(df){ 
	df |> 
    mutate(obs_med = median(times),
           obs_tr_mean = mean(times, trim = 0.25)) |>
    sample_frac(size=1, replace=TRUE) |>
    summarize(boot_med = median(times), 
              boot_tr_mean = mean(times, trim = 0.25),
              obs_med = mean(obs_med),
              obs_tr_mean = mean(obs_tr_mean))}
```

## resample function
```{r}
boot_1_func <- function(df){
  df |> 
    sample_frac(size=1, replace=TRUE)
}
```

## bootstrapping
```{r}
map(1:n_rep1, ~boot_stat_func(df = heroin)) |> 
  list_rbind()
```

:::





## **Data** distributions 

:::: {.columns}

::: {.column width=50%}
```{r}
#| echo: false 
#| fig-width: 4
heroin |> 
  ggplot(aes(x=times)) + ylab("") +
  geom_histogram(bins=30) + 
  ggtitle("original sample")
```
:::

::: {.column width=50%}
```{r}
#| echo: false 
#| fig-width: 4
heroin |>
  boot_1_func() |>
  ggplot(aes(x=times)) + ylab("") +
  geom_histogram(bins=30) + 
  ggtitle("one bootstrap resample")
```
:::
::::



## **Sampling** distributions 

Both the median and the trimmed mean are reasonably symmetric and bell-shaped.  

:::: {.columns}

::: {.column width=50%}
```{r echo=FALSE, fig.width=4, fig.height=6}
boot_stats <- map(1:n_rep1, ~boot_stat_func(df = heroin)) |> 
  list_rbind()

ggplot(boot_stats, aes(x=boot_med)) + 
  geom_histogram(bins=20) + 
  ggtitle("dist of median") +  ylab("") +
  xlim(c(300, 475)) +
  geom_vline(aes(xintercept = mean(boot_med))) 
  #xlab(paste("mean=",round(mean(boot_med),2),";
  #           SE=", round(sd(boot_med),2)))
```
:::

::: {.column width=50%}
```{r echo=FALSE, fig.width=4, fig.height=6}
ggplot(boot_stats, aes(x=boot_tr_mean)) + 
  geom_histogram(bins=20) + 
  ggtitle("dist of trimmed mean") +  ylab("") +
  xlim(c(300, 475)) +
  geom_vline(aes(xintercept = mean(boot_med))) 
  #xlab(paste("mean=",round(mean(boot_tr_mean),2),";
  #           SE=", round(sd(boot_tr_mean),2)))

```
:::

::::



# Agenda 10/6 + 8/25

1. Logic of CI
2. Normal CI using BS SE
3. Bootstrap-t (studentized) CIs 



## Technical derivations

See in class notes on [bootstrapping](https://st47s.com/Math154/Notes/06-bootstrap.html) for the technical details on how to create different bootstrap intervals.


## Bootstrap condition:

The sampling distribution we generate with bootstrap resamples asymptotically approaches the true sampling distribution of $\hat{\theta}$ as the sample size of the data goes up: $n \rightarrow \infty$.

\begin{align}
\hat{F}\Big(\frac{\hat{\theta}^*(b) - \hat{\theta}}{\hat{SE}^*(b)} \Big) \rightarrow F\Big(\frac{\hat{\theta} - \theta}{SE(\hat{\theta})}\Big)
\end{align}

# Normal CI using bootstrap SE

Building on derivation for CI from introductory statistics, we can use the bootstrap standard error.

## CI for $\theta$

If: $\hat{\theta} \sim N$

\begin{align}
P\bigg(z_{(\alpha/2)} \leq \frac{\hat{\theta} - \theta}{SE(\hat{\theta})} \leq z_{(1-\alpha/2)}\bigg)&= 1 - \alpha\\
P\bigg(\hat{\theta} - z_{(1-\alpha/2)} SE(\hat{\theta}) \leq \theta \leq \hat{\theta} - z_{(\alpha/2)} SE(\hat{\theta})\bigg) &= 1 - \alpha\\
\end{align}

## CI for $\theta$ with bootstrap SE

A 95% CI for $\theta$ would then be: $$\hat{\theta} \pm z_{(\alpha/2)} \hat{SE}^*$$


## Bootstrapping with `map()`

::: {.panel-tabset}

## set variables
```{r}
n_rep1 <- 100
set.seed(4747)
```

## boot stat function
```{r}
boot_stat_func <- function(df){ 
	df |> 
    mutate(obs_med = median(times),
           obs_tr_mean = mean(times, trim = 0.25)) |>
    sample_frac(size=1, replace=TRUE) |>
    summarize(boot_med = median(times), 
              boot_tr_mean = mean(times, trim = 0.25),
              obs_med = mean(obs_med),
              obs_tr_mean = mean(obs_tr_mean))}
```

## bootstrap!
```{r}
boot_stats <- map(1:n_rep1, ~boot_stat_func(df = heroin)) |> 
  list_rbind()

boot_stats
```

:::


## 95% normal CI with BS SE

```{r}
boot_stats |>
  summarize(
    low_med = mean(obs_med) + qnorm(0.025) * sd(boot_med),
    up_med = mean(obs_med) + qnorm(0.975) * sd(boot_med),
    low_tr_mean = mean(obs_tr_mean) + qnorm(0.025) * sd(boot_tr_mean),
    up_tr_mean = mean(obs_tr_mean) + qnorm(0.975) * sd(boot_tr_mean))
```



# Bootstrap-t CI

What if we don't believe that $\hat{\theta} \sim N$?

## Double bootstrap to find the multiplier

\begin{align}
T^*(b) &= \frac{\hat{\theta}^*(b) - \hat{\theta}}{\hat{SE}^*(b)}
\end{align}

(**different** $\hat{SE}^*(b)$ for every bootstrap resample!)

## CI multiplier

Find $\hat{t}^*_{\alpha/2}$

\begin{align}
\frac{\# \{T^*(b) \leq \hat{t}^*_{\alpha/2} \} }{B} = \alpha/2
\end{align}

## Bootstrap-t CI

$(\hat{\theta} - \hat{t}^*_{1-\alpha/2}\hat{SE}^*,  \hat{\theta} - \hat{t}^*_{\alpha/2}\hat{SE}^*)$

## Double bootstrapping with `map()`

::: {.panel-tabset}

## set variables
```{r}
n_rep1 <- 100
n_rep2 <- 20
set.seed(4747)
```

## boot stat function
```{r}
boot_stat_func <- function(df){ 
	df |> 
    mutate(obs_med = median(times),
           obs_tr_mean = mean(times, trim = 0.25)) |>
    sample_frac(size=1, replace=TRUE) |>
    summarize(boot_med = median(times), 
              boot_tr_mean = mean(times, trim = 0.25),
              obs_med = mean(obs_med),
              obs_tr_mean = mean(obs_tr_mean))}
```

## resample function
```{r}
boot_1_func <- function(df){
  df |> 
    sample_frac(size=1, replace=TRUE)
}
```

## re-resample function
```{r}
boot_2_func <- function(df, reps){
  resample2 <- 1:reps
  df |>
    summarize(boot_med = median(times), boot_tr_mean = mean(times, trim = 0.25)) |>
    cbind(resample2, map(resample2, ~df |> 
            sample_frac(size=1, replace=TRUE) |>
            summarize(boot_2_med = median(times), 
                       boot_2_tr_mean = mean(times, trim = 0.25))) |>
                list_rbind()) |> 
    select(resample2, everything())
}
```

## double bootstrap!
```{r}
boot_2_stats <- data.frame(resample1 = 1:n_rep1) |>
  mutate(first_boot = map(1:n_rep1, ~boot_1_func(df = heroin))) |>
  mutate(second_boot = map(first_boot, boot_2_func, reps = n_rep2)) 
```

```{r eval = FALSE, include = FALSE}
boot_2_stats #|>
  #unnest(second_boot) |>
  #unnest(first_boot)
```

:::




## Summarizing the double bootstrap


::: {.panel-tabset}

## results
```{r}
boot_2_stats |>
  unnest(second_boot) |>
  unnest(first_boot) 
```

## summary for resample 1
```{r eval = FALSE}
boot_2_stats |>
  unnest(second_boot) |>
  unnest(first_boot) |>
  filter(resample1 == 1) 
```

```{r echo = FALSE}
boot_2_stats |>
  unnest(second_boot) |>
  unnest(first_boot) |>
  select(resample1, resample2, everything() ) |>
  filter(resample1 == 1) |>
  select(boot_med, boot_tr_mean, boot_2_med, boot_2_tr_mean) |>
  skim_without_charts() |> as_tibble() |> 
  select(skim_variable, numeric.mean, numeric.sd, numeric.p50)
```

## summary for all resamples

```{r}
boot_t_stats <- boot_2_stats |>
  unnest(second_boot) |>
  unnest(first_boot) |>
  group_by(resample1) |>
  summarize(boot_sd_med = sd(boot_2_med),
            boot_sd_tr_mean = sd(boot_2_tr_mean),
            boot_med = mean(boot_med),  # doesn't do anything, just copies over
            boot_tr_mean = mean(boot_tr_mean))  |> # the variables into the output
  mutate(boot_t_med = (boot_med - mean(boot_med)) / boot_sd_med,
            boot_t_tr_mean = (boot_tr_mean - mean(boot_tr_mean)) / boot_sd_tr_mean)

  
boot_t_stats

```

:::



## 95% Bootstrap-t CI


Note that the t-value is needed (which requires a different SE for each bootstrap sample).


::: {.panel-tabset}

## t-values
```{r}
boot_t_stats |>
  select(boot_t_med, boot_t_tr_mean)
```

## multipliers
```{r}
boot_q <- boot_t_stats |>
  select(boot_t_med, boot_t_tr_mean) |>
  summarize(q_t_med = quantile(boot_t_med, c(0.025, 0.975)), 
            q_t_tr_mean = quantile(boot_t_tr_mean, c(0.025, 0.975)),
            q = c(0.025, 0.975))

boot_q
```

## pull numbers
```{r}
boot_q_med <- boot_q |> select(q_t_med) |> pull()
boot_q_med

boot_q_tr_mean <- boot_q |> select(q_t_tr_mean) |> pull()
boot_q_tr_mean

```

## BS-t CI
```{r}
boot_t_stats |>
  summarize(boot_t_CI_med = mean(boot_med) + boot_q_med*sd(boot_med),
            boot_t_CI_tr_mean = mean(boot_tr_mean) + boot_q_tr_mean * sd(boot_tr_mean),
            q = c(0.025, 0.975))

```

:::


## Bootstrapping with `map()`

::: {.panel-tabset}

## set variables
```{r}
n_rep1 <- 100
set.seed(4747)
```

## boot stat function
```{r}
boot_stat_func <- function(df){ 
	df |> 
    mutate(obs_med = median(times),
           obs_tr_mean = mean(times, trim = 0.25)) |>
    sample_frac(size=1, replace=TRUE) |>
    summarize(boot_med = median(times), 
              boot_tr_mean = mean(times, trim = 0.25),
              obs_med = mean(obs_med),
              obs_tr_mean = mean(obs_tr_mean))}
```

## bootstrap!
```{r}
boot_stats <- map(1:n_rep1, ~boot_stat_func(df = heroin)) |> 
  list_rbind()

boot_stats
```

:::


# Agenda 10/15/25
1. Percentile CIs
2. properties / advantages / disadvantages



# 95% Percentile CI

Theoretically more sophisticated but computationally more straightforward, we can directly use the percentiles of the sampling distribution to derive a CI.

## Calculating the Percentile CI

```{r}
boot_stats |>
  summarize(perc_CI_med = quantile(boot_med, c(0.025, 0.975)), 
            perc_CI_tr_mean = quantile(boot_tr_mean, c(0.025, 0.975)), 
            q = c(0.025, 0.975))
```


## Comparison of intervals

The first three columns  correspond to the CIs for the true median of the survival times.  The second three columns correspond to the CIs for the true trimmed mean of the survival times.


| CI          | Lower  | Obs Med | Upper  | Lower  | Obs Tr Mean | Upper  |
|-------------|--------|---------|--------|--------|-------------|--------|
| Percentile  | 321    | 367.50  | 434.58 | 334.86 | 378.30      | 419.77 |
| w BS SE     | 309.99 | 367.50  | 425.01 | 336.87 | 378.30      | 419.73 |
| BS-t        | 309.30 | 367.50  | 425.31 | 331.03 | 378.30      | 421.17 |

(Can't know what the *Truth* is...)


## What makes a confidence interval procedure good?

**Most Important**

1. That it captures the true parameter in $(1-\alpha) \cdot$ 100% of the datasets.

2. That it produces narrow intervals.


## What makes a confidence interval procedure good?


* Symmetry (??): the interval is symmetric, pivotal around some value.  Not necessarily a good thing.  Maybe a bad thing to force?
* Resistant: BS-t is particularly not resistant to outliers or skewed sampling distributions of the statistic (can make it more robust with a variance stabilizing transformation)
* Range preserving: the CI always contains only values that fall within an allowable range ($p, \rho$,...)
* Transformation respecting: for any monotone transformation, $\phi = m(\theta)$, the interval for $\theta$ is mapped directly by $m(\theta)$.  If $[\hat{\theta}_{(lo)},\hat{\theta}_{(hi)}]$ is a $(1-\alpha)100$% interval for $\theta$, then

$$[\hat{\phi}_{(lo)},\hat{\phi}_{(hi)}] = [m(\hat{\theta}_{(lo)}),m(\hat{\theta}_{(hi)})]$$
are exactly the same interval.

* Level of confidence: A central (not symmetric) confidence interval, $[\hat{\theta}_{(lo)},\hat{\theta}_{(hi)}]$ should have probability $\alpha/2$ of not covering $\theta$ from above or below:

\begin{align}
P(\theta < \hat{\theta}_{(lo)})&=\alpha/2\\
P(\theta > \hat{\theta}_{(hi)})&=\alpha/2\\
\end{align}

* Note:  all of the intervals are approximate.  We judge them based on how accurately they cover $\theta$.

    * A CI is first order accurate if:
\begin{align}
P(\theta < \hat{\theta}_{(lo)})&=\alpha/2 + \frac{const_{lo}}{\sqrt{n}}\\
P(\theta > \hat{\theta}_{(hi)})&=\alpha/2+ \frac{const_{hi}}{\sqrt{n}}\\
\end{align}


    * A CI is second order accurate if:
\begin{align}
P(\theta < \hat{\theta}_{(lo)})&=\alpha/2 + \frac{const_{lo}}{n}\\
P(\theta > \hat{\theta}_{(hi)})&=\alpha/2+ \frac{const_{hi}}{n}\\
\end{align}



## What else about intervals?

| **CI**      | **Symmetric** | **Range Resp** | **Trans Resp** | **Accuracy**  | **Normal Samp Dist?** | **Other**                              |
|-------------|---------------|----------------|----------------|---------------|-----------------------|----------------------------------------|
| **Boot SE** | Yes           | No             | No             | 1st order     | Yes                   | Parametric assumptions, $F(\hat{\theta})$ |
| **Boot-t**  | No            | No             | No             | 2nd order     | No                | Computationally intensive              |
| **perc**    | No            | Yes            | Yes            | 1st order     | No                    | Small $n \rightarrow$ low accuracy             |
| **BCa**     | No            | Yes            | Yes            | 2nd order     | No                    | Limited parametric assumptions         |

## Advantages and Disadvantages


* Normal Approximation
    * **Advantages** similar to the familiar parametric approach; useful with a normally distributed $\hat{\theta}$; requires the least computation ($B=50-200$)
    * **Disadvantages** fails to use the entire $\hat{F}^*(\hat{\theta}^*)$; only works if $\hat{\theta}$ is reasonably normal to start with

* Bootstrap-t Confidence Interval
    * **Advantages**  highly accurate CI in many cases; handles skewed $F(\hat{\theta})$ better than the percentile method
    * **Disadvantages**  not invariant to transformations; computationally expensive with the double bootstrap; coverage probabilities are best if the distribution of $\hat{\theta}$ is nice (e.g., normal)
    
* Percentile
    * **Advantages**  uses the entire $\hat{F}^*(\hat{\theta}^*)$; allows $F(\hat{\theta})$ to be asymmetrical; invariant to transformations; range respecting; simple to execute
    * **Disadvantages**  small samples may result in low accuracy (because of the dependence on the tail behavior); assumes $\hat{F}^*(\hat{\theta}^*)$ to be unbiased
    
* BCa
    * **Advantages** 
all of those of the percentile method; allows for bias in $\hat{F}^*(\hat{\theta}^*)$; $z_0$ can be calculated easily from $\hat{F}^*(\hat{\theta}^*)$
    * **Disadvantages**  requires a limited parametric assumption; more computational than other intervals




## References

